from lib import ast_z
from lib.const_z import TypesZ

class ParserZ:
    def __init__(self, sz):
        self.sz = sz
        self.current_token = None

    def eat(self, z_type):
        import pdb; pdb.set_trace()
        if self.current_token != z_type.value:
            raise Exception('Expected type {}, got type {}'.format(
                z_type.value, self.current_token.z_type)
            )
        else:
            self.current_token = self.sz.tokenize()
    
    def zephyr(self):
        self.eat(TypesZ.LBRACE)
        node = self.expr()
        self.eat(TypesZ.RBRACE)
        return node

    def expr(self):
        node = self.term()
        return node

    def term(self):
        node = self.factor()
        
        while self.current_token.z_type in (
            TypesZ.MUL, TypesZ.DIV
        ):
            op_type = self.current_token.z_type
            self.eat(op_type)
            node = ast_z.BinOpNode(
                left=node,
                op=op_type,
                right=self.term()
            )
        return node

    def factor(self):
        node = None
        import pdb; pdb.set_trace()
        if self.current_token.z_type == TypesZ.INTEGER:
            node = ast_z.IntegerNode(self.current_token)
            self.eat(TypesZ.INTEGER)
        elif self.current_token.z_type == TypesZ.REAL:
            node = ast_z.RealNode(self.current_token)
            self.eat(TypesZ.REAL)
        return node

    def parse(self):
        self.current_token = self.sz.tokenize()
        tree = self.zephyr()
        if self.current_token is not None:
            raise Exception(
                'After parsing, current_token should be None, '
                'instead got %s.' % self.current_token.z_type
            )
        return tree

